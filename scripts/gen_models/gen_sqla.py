"""
Generate SQLAlchemy ORM models.

Utility script for  SDX that inspects Pydantic models
(from both `fhir_models` and `custom_models`) and produces a basic
SQLAlchemy 2.x ORM layer with one table per Pydantic class.

Usage:
    python generate_orm_models.py

Output:
    Overwrites/creates `telehealthcare_ai/db/orm_models.py`
    with autogenerated Declarative mapping code.

Notes
-----
* Only scalar field types (str, int, float, bool, datetime) and simple
  collections are handled automatically. Complex nested objects will be
  serialised into JSON columns.
* Relationships (foreign keys) are not inferred; add them manually.
* Requires pydantic>=2.0, SQLAlchemy>=2.0.
"""

from __future__ import annotations

import sys

from datetime import date, datetime
from pathlib import Path
from types import ModuleType
from typing import Any, Dict, Type

from formatting import run_ruff
from gen_base import is_concrete_model, iter_pydantic_models
from pydantic import BaseModel
from sdx.schema.fhir import BaseLanguage

# Target file to (over)write
OUTPUT_PATH = (
    Path(__file__).resolve().parent.parent.parent
    / 'src'
    / 'sdx'
    / 'models'
    / 'sqla'
    / 'fhir.py'
)


TYPE_MAP = {
    str: 'String',
    int: 'Integer',
    float: 'Float',
    bool: 'Boolean',
    datetime: 'DateTime',
    date: 'Date',
}

# Fallback SQLAlchemy type for arbitrary / nested data
FALLBACK_TYPE = 'JSON'


def python_type_to_sqla(annotation: Any) -> tuple[str, str]:
    """
    Return a pair ``(sqlalchemy_type_name, python_hint_string)``.

    * Scalars map to a concrete SA type and their own type-name hint
      (e.g. ``("String", "str")``).
    * Lists / dicts / unknown objects fall back to JSON + ``Any``.
    """
    origin = getattr(annotation, '__origin__', None)

    # Generic collections → JSON
    if origin in (list, dict):
        return FALLBACK_TYPE, 'Any'

    # Exact scalar matches
    if annotation in TYPE_MAP:
        return TYPE_MAP[annotation], annotation.__name__

    #   sqlalchemy.DateTime  ←  datetime | Arrow | pendulum types
    if annotation is datetime:
        return 'DateTime', 'datetime'

    # Anything else → JSON
    return FALLBACK_TYPE, 'Any'


def generate_sqla_model(name: str, model_cls: Type[BaseModel]) -> str:
    """
    Create a SQLAlchemy declarative model class for a given Pydantic model.

    Rules
    -----
    * If the Pydantic model has **no scalar field** that can act
      as a primary key, inject a surrogate UUID ``id`` column.
    * Non-scalar or complex fields are mapped to JSON columns.
    """
    lines: list[str] = []
    table_name = name.lower()
    lines.append(f'class {name}(Base):')
    lines.append(f"    __tablename__ = '{table_name}'")
    lines.append('')

    fields = model_cls.model_fields

    has_scalar_pk_candidate = any(
        python_type_to_sqla(field.annotation)[0] != FALLBACK_TYPE
        for field in fields.values()
    )
    inject_uuid_pk = not has_scalar_pk_candidate

    if inject_uuid_pk:
        lines.append(
            '    id: Mapped[str] = mapped_column('
            'String(36), primary_key=True, '
            'default=lambda: str(uuid.uuid4())'
            ')'
        )

    for field_name, field_info in fields.items():
        # Skip if surrogate PK already added
        if inject_uuid_pk and field_name == 'id':
            continue

        sa_type, py_hint = python_type_to_sqla(field_info.annotation)

        nullable = 'True' if not field_info.is_required() else 'False'
        primary = (
            'True' if (field_name == 'id' and not inject_uuid_pk) else 'False'
        )

        col_args = [
            sa_type,
            'primary_key=True' if primary == 'True' else None,
            'nullable=True' if nullable == 'True' else None,
            'index=True' if primary == 'False' else None,
        ]
        col_args = ', '.join(arg for arg in col_args if arg)

        lines.append(
            f'    {field_name}: Mapped[{py_hint}] = mapped_column({col_args})'
        )

    lines.append('')
    return '\n'.join(lines)


def build_orm_file(models: Dict[str, Type[BaseModel]]) -> str:
    """Compose the full orm_models.py content."""
    header = """\"\"\"Autogenerated ORM models from Pydantic schemas.

DO NOT EDIT MANUALLY. Regenerate via `python generate_orm_models.py`.
\"\"\"

from __future__ import annotations

import datetime
import uuid

from typing import Any, Optional, Union  # noqa

from fhir.resources.fhirtypes import (
    ReferenceType,  # noqa
    CodeableConceptType,  # noqa
)
from public import public
from sqlalchemy import (
    Boolean,  # noqa
    Date,  # noqa
    DateTime,  # noqa
    Float,  # noqa
    Integer,  # noqa
    JSON,  # noqa
    String,  # noqa
    Text,  # noqa
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


@public
class Base(DeclarativeBase):
    \"\"\"Declarative base for  SDX.\"\"\"
    pass

"""
    body = []
    for model_cls in models.values():
        if not is_concrete_model(model_cls):
            continue
        body += [
            '@public\n' + generate_sqla_model(model_cls.__name__, model_cls)
        ]

    return header + '\n\n'.join(body) + '\n'


def main() -> None:
    """Execute the main function."""
    models = iter_pydantic_models()
    orm_code = build_orm_file(models)

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text(orm_code, encoding='utf-8')

    print(f'[✓] ORM models written to {OUTPUT_PATH}')

    try:
        run_ruff(OUTPUT_PATH, fix=True)
    except RuntimeError as err:
        # Fallback: continue without failing the generator
        print(f'[!] Ruff step skipped: {err}')


if __name__ == '__main__':
    sys.exit(main())
