"""
Auto-generate SQLModel tables from all concrete Pydantic models.

Each Pydantic model discovered by `iter_pydantic_models()` becomes one
SQLModel class with ``table=True``.  Complex / unknown field types are
stored in PostgreSQL JSONB columns.

Output file:
    src/sdx/models/sqlmodel/fhir.py      (overwritten)
"""

from __future__ import annotations

import sys

from datetime import date, datetime
from pathlib import Path
from typing import Any, Dict, Type, get_args, get_origin

from formatting import run_ruff
from gen_base import is_concrete_model, iter_pydantic_models
from pydantic import BaseModel

OUTPUT_PATH = (
    Path(__file__).resolve().parent.parent.parent
    / 'src'
    / 'sdx'
    / 'models'
    / 'sqlmodel'
    / 'fhir.py'
)

TYPE_MAP = {
    str: 'String',
    int: 'Integer',
    float: 'Float',
    bool: 'Boolean',
    datetime: 'DateTime',
    date: 'Date',
}

FALLBACK_TYPE = 'JSON'


def _hint_str(annotation: Any) -> str:
    origin = getattr(annotation, '__origin__', '')

    ann_name = getattr(annotation, '_name', '')

    if not ann_name:
        return 'str'

    if origin:
        ann_name = _hint_str(annotation.__origin__)

    if ann_name.lower() in ('list', 'dict'):
        ann_name = ann_name.lower()

    if not getattr(annotation, '__args__', []):
        return ann_name

    ann_args = []
    for arg in getattr(annotation, '__args__', []):
        arg_name = getattr(arg, '__name__', '')

        if not arg_name:
            continue

        arg_name = 'None' if arg_name == 'NoneType' else arg_name

        if arg_name.lower() in ('list', 'dict'):
            arg_name = arg_name.lower()
            if arg_name == 'list':
                arg_name = f'{arg_name}[str]'
            if arg_name == 'dict':
                arg_name = f'{arg_name}[str, str]'

        if arg_name == 'Annotated':
            arg_name = 'str'

        ann_args.append(arg_name)

    if not ann_args or ann_name == 'str':
        return ann_name

    return f'{ann_name}[{", ".join(ann_args)}]'


def python_to_sa_type(annotation: Any) -> str:
    """
    Return a SQLAlchemy column-type name as *string* given a field annotation.

    • Plain scalars → explicit SA type
    • Optional[T]   → check the inner type
    • Collection    → JSONB
    • Unknown       → JSONB
    """
    origin = get_origin(annotation)

    if origin is type(None):
        return python_to_sa_type(get_args(annotation)[0])

    if origin in (list, dict):
        return FALLBACK_TYPE

    return TYPE_MAP.get(annotation, FALLBACK_TYPE)


def generate_sqlmodel_class(name: str, model_cls: Type[BaseModel]) -> str:
    """Return the SQLModel table class as source."""
    lines: list[str] = []
    tablename = name.lower()

    lines.append('@public')
    lines.append(f'class {name}(SQLModel, table=True):')
    lines.append(f'    """{name} autogenerated."""\n')
    lines.append(f"    __tablename__: ClassVar[str] = '{tablename}'")
    lines.append('')

    fields = model_cls.model_fields

    inject_uuid_pk = 'id' not in fields

    if inject_uuid_pk:
        lines.append(
            '    id: str | None = Field('
            'default_factory=lambda: str(uuid.uuid4()), '
            'primary_key=True, sa_type=String)'
        )

    for fname, finfo in fields.items():
        if inject_uuid_pk and fname == 'id':
            continue

        sa_type = python_to_sa_type(finfo.annotation)
        nullable = not finfo.is_required()

        params: list[str] = []

        is_pk = fname == 'id'

        if is_pk:
            params.append('default_factory=lambda: str(uuid.uuid4())')
        else:
            params.append('default=None' if nullable else 'default=...')

        params.append(f'primary_key={is_pk!r}')
        params.append(f'nullable={nullable!r}')
        params.append(f'index={not is_pk!r}')
        params.append(f'sa_type={sa_type}')

        params_str = ', '.join(params)

        lines.append(
            f'    {fname}: {_hint_str(finfo.annotation)} = Field({params_str})'
        )

    lines.append('')
    return '\n'.join(lines)


def build_module_code(models: Dict[str, Type[BaseModel]]) -> str:
    """Compose the full code for `fhir.py`."""
    header = """\"\"\"Autogenerated SQLModel tables from Pydantic schemas.

DO NOT EDIT MANUALLY:
    regenerate via `python scripts/gen_models/gen_sqlmodel.py`.
\"\"\"

from __future__ import annotations

import uuid
from typing import Annotated, Any, ClassVar, Literal, Optional, Union

from public import public
from sqlalchemy import (
    Boolean,
    Date,
    DateTime,
    Float,
    Integer,
    String,
    JSON,
)
from sqlmodel import Field, SQLModel
"""
    body: list[str] = []
    for mdl in models.values():
        if not is_concrete_model(mdl):
            continue
        body.append(generate_sqlmodel_class(mdl.__name__, mdl))

    return header + '\n\n'.join(body) + '\n'


def main() -> None:
    """Define the main function."""
    models = iter_pydantic_models()
    module_code = build_module_code(models)

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text(module_code, encoding='utf-8')
    print(f'[✓] SQLModel tables written to {OUTPUT_PATH}')

    # Optional formatting via Ruff
    try:
        run_ruff(OUTPUT_PATH, fix=True)
    except RuntimeError as exc:
        print(f'[!] Ruff skipped: {exc}')


if __name__ == '__main__':
    sys.exit(main())
