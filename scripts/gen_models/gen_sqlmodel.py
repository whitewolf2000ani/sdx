"""
Auto-generate SQLModel tables from all concrete Pydantic models.

Each Pydantic model discovered by `iter_pydantic_models()` becomes one
SQLModel class with ``table=True``.  Complex / unknown field types are
stored in PostgreSQL JSONB columns.

Output file:
    src/sdx/models/sqlmodel/fhir.py      (overwritten)
"""

from __future__ import annotations

import sys
import uuid

from datetime import date, datetime
from pathlib import Path
from typing import Any, Dict, Type, get_args, get_origin

from formatting import run_ruff
from gen_base import is_concrete_model, iter_pydantic_models
from pydantic import BaseModel

# --------------------------------------------------------------------------- #
# Configuration
# --------------------------------------------------------------------------- #

OUTPUT_PATH = (
    Path(__file__).resolve().parent.parent.parent
    / 'src'
    / 'sdx'
    / 'models'
    / 'sqlmodel'
    / 'fhir.py'
)

TYPE_MAP = {
    str: 'String',
    int: 'Integer',
    float: 'Float',
    bool: 'Boolean',
    datetime: 'DateTime',
    date: 'Date',
}

FALLBACK_TYPE = 'JSONB'  # uses PostgreSQL JSONB by default


# --------------------------------------------------------------------------- #
# Helpers
# --------------------------------------------------------------------------- #


def python_to_sa_type(annotation: Any) -> str:
    """
    Return a SQLAlchemy column-type name as *string* given a field annotation.

    • Plain scalars → explicit SA type
    • Optional[T]   → check the inner type
    • Collection    → JSONB
    • Unknown       → JSONB
    """
    origin = get_origin(annotation)

    # Optional[T] is Union[T, NoneType]
    if origin is type(None):
        # pragma: no cover – not expected
        return python_to_sa_type(get_args(annotation)[0])

    # List / Dict / Any generic collection
    if origin in (list, dict):
        return FALLBACK_TYPE

    return TYPE_MAP.get(annotation, FALLBACK_TYPE)


def generate_sqlmodel_class(name: str, model_cls: Type[BaseModel]) -> str:
    """
    Create a SQLModel class definition as a *string*.

    Injects a surrogate UUID primary key if the model lacks a scalar field.
    """
    lines: list[str] = []
    tablename = name.lower()

    lines.append(f'@public')
    lines.append(f'class {name}(SQLModel, table=True):')
    lines.append(f"    __tablename__: str = '{tablename}'")
    lines.append('')

    fields = model_cls.model_fields

    # Decide if a scalar PK exists
    has_scalar = any(
        python_to_sa_type(f.annotation) != FALLBACK_TYPE
        for f in fields.values()
    )
    inject_uuid_pk = not has_scalar

    if inject_uuid_pk:
        lines.append(
            '    id: str | None = Field('
            'default_factory=lambda: str(uuid.uuid4()),'
            'primary_key=True,'
            'sa_type=String(36),'
            ')'
        )

    for fname, finfo in fields.items():
        # Skip duplicate id when surrogate already inserted
        if inject_uuid_pk and fname == 'id':
            continue

        sa_type = python_to_sa_type(finfo.annotation)
        nullable = not finfo.is_required()
        is_pk = fname == 'id' and not inject_uuid_pk
        param_1 = 'None' if nullable else '...'

        lines.append(
            f'    {fname}: {finfo.annotation.__name__ if hasattr(finfo.annotation, "__name__") else "Any"} '
            f'= Field('
            f'{param_1}, '
            f'primary_key={is_pk!r}, '
            f'nullable={nullable!r}, '
            f'index={not is_pk!r}, '
            f'sa_type={sa_type},'
            f')'
        )

    lines.append('')
    return '\n'.join(lines)


def build_module_code(models: Dict[str, Type[BaseModel]]) -> str:
    """Compose the full code for `fhir.py`."""
    header = """\"\"\"Autogenerated SQLModel tables from Pydantic schemas.

DO NOT EDIT MANUALLY:
    regenerate via `python scripts/gen_models/gen_sqlmodel.py`.
\"\"\"

from __future__ import annotations

import uuid
from typing import Any, Optional

from public import public
from sqlalchemy import (
    Boolean,
    Date,
    DateTime,
    Float,
    Integer,
    String,
    JSON,
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlmodel import Field, SQLModel
"""
    body: list[str] = []
    for mdl in models.values():
        if not is_concrete_model(mdl):
            continue
        body.append(generate_sqlmodel_class(mdl.__name__, mdl))

    return header + '\n\n'.join(body) + '\n'


# --------------------------------------------------------------------------- #
# Main entry point
# --------------------------------------------------------------------------- #


def main() -> None:
    models = iter_pydantic_models()
    module_code = build_module_code(models)

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text(module_code, encoding='utf-8')
    print(f'[✓] SQLModel tables written to {OUTPUT_PATH}')

    # Optional formatting via Ruff
    try:
        run_ruff(OUTPUT_PATH, fix=True)
    except RuntimeError as exc:
        print(f'[!] Ruff skipped: {exc}')


if __name__ == '__main__':
    sys.exit(main())
